@using System.Diagnostics
@using FaasNet.EventMesh.Client.Messages
@using FaasNet.EventMesh.Client.StateMachines.Client
@using FaasNet.EventMesh.UI.Helpers
@using FaasNet.EventMesh.UI.Stores.App
@using FaasNet.EventMesh.UI.Stores.ApplicationDomains
@using FaasNet.EventMesh.UI.Stores.Client
@using FaasNet.EventMesh.UI.Stores.EventDef
@using Fluxor
@using Fluxor.Blazor.Web.Components
@inherits FluxorComponent

<div>
    <button class="btn btn-primary" @onclick="(e) => Update()">Save UI</button>
</div>

<div id="asyncApiContainer">
    <div id="toolbox">
        <ul>
            @if (Mode == EditionModes.EDIT)
            {
                <li>
                    <i @onclick="() => HandleStartViewMode()" class="fa-solid fa-arrows-up-down-left-right"></i>
                </li>
            }
            else
            {                
                <li>
                    <i @onclick="() => HandleStartEditMode()" class="fa-solid fa-pen-to-square"></i>
                </li>
            }
        </ul>
    </div>
    <div id="elements">
        <div class="element" draggable="true" ondragstart="event.dataTransfer.setData('application', '')">
            Application
        </div>
    </div>
    @if(ActiveApplication != null)
    {
        <AsyncApiApplicationProperties ActiveApplication="@ActiveApplication" ApplicationClosed="@HandleCloseApplication" Vpn="@Vpn" />
    }

    @if(ActiveLink != null) 
    {
        <AsyncApiLinkProperties Vpn="@Vpn" ActiveLink="@ActiveLink" LinkClosed="@HandleCloseLink" LinkRemoved="@RemoveLink"></AsyncApiLinkProperties>
    }

    <svg id="editor" class="@(Mode == EditionModes.VIEW ? "moving" : "")" viewBox="@ViewBox" 
                @onmousewheel="HandleMouseWheel" 
                @onmousewheel:stopPropagation="true"
                @ondrop="HandleDrop" 
                ondragover="event.preventDefault();" 
                @onmousedown="HandleMouseDown" 
                @onmousemove="HandleMouseMove" 
                @onmouseup="HandleMouseUp">
        <defs>
            <marker id="asyncapieditor-barbEnd" refX="19" refY="7" markerWidth="20" markerHeight="14" markerUnits="strokeWidth" orient="auto">
                <path d="M 19,7 L9,13 L14,7 L9,1 Z"></path>
            </marker>
        </defs>
        <g class="children">
            @foreach (var application in Applications)
            {
                <g class="@(application.GetClassName(SelectedApplication?.ClientId, ActiveApplication?.ClientId))" 
                        transform="@application.Matrix" 
                        @onmousedown="(e) => HandleSelectApplication(e, application)" 
                        @onmousedown:stopPropagation="true">
                    <foreignObject width="@application.Width" height="@application.Height" class="appContainer">
                        @foreach(var anchor in application.Anchors)
                        {                            
                            <div class="@anchor.ClassName" @onmouseover="() => HandleMouseOver(application, anchor)" @onmouseout="HandleMouseOut" @onmousedown="(e) => HandleStartDrawLink(e, application.ClientId, anchor.Position)" @onmousedown:preventDefault="true" @onmousedown:stopPropagation="true"></div>
                        }
                        <ul class="actions">
                            <li><i class="fa-solid fa-trash" @onclick="(e) => RemoveApplication(application)"></i></li>
                        </ul>
                        <div class="content">
                            <div class="header">
                                @application.ClientId
                            </div>
                        </div>
                    </foreignObject>
                </g>
            }

            @foreach(var link in Links)
            {
                <path d="@link.Path" marker-end="url(#asyncapieditor-barbEnd)" stroke="@link.Color" fill="none"></path>
                <g transform="@link.SelectionContainerMatrix">
                    <foreignObject width="@link.SelectionContainerWidth" height="@link.SelectionContainerHeight"
                        @onmousedown="(e) => HandleSelectLink(e, link)"
                        @onmousedown:stopPropagation="true"
                        class="@link.SelectionContainerClass">
                        <div class="selectionContainer"></div>
                        <ul class="actions">
                            <li><i class="fa-solid fa-trash" @onclick="() => RemoveLink(link)"></i></li>
                        </ul>
                    </foreignObject>
                </g>
            }
        </g>
        @if(SelectedApplication != null)
        {
            <g class="application" transform="@SelectedApplication.Matrix" draggable="true">
                <foreignObject width="@SelectedApplication.Width" height="@SelectedApplication.Height" class="appContainer">
                    <div class="content">
                        <div class="header">
                            @SelectedApplication.ClientId
                        </div>
                    </div>
                </foreignObject>
            </g>
        }

        @if(SelectedLink != null)
        {
            <path d="@SelectedLink.Path" marker-end="url(#asyncapieditor-barbEnd)" stroke="black" fill="none"></path>
        }
    </svg>
</div>

<AsyncApiEventDef EvtDefSelected="@HandleSelectEvtDef" @ref="addEventDef" Vpn="@Vpn" />
<AsyncApiClient ClientSelected="@HandleSelectClient" Vpn="@Vpn" @ref="addClient" />

@code {
    const int WIDTH = 200;
    const int PADDING = 20;
    private string ViewBox { get; set; } = null!;
    private EditionModes Mode { get; set; } = EditionModes.EDIT;
    private bool StartMoving { get; set; } = false;
    private bool IsApplicationMoving { get; set; } = false;
    [Parameter] public ICollection<ApplicationViewModel> Applications { get; set; } = new List<ApplicationViewModel>();
    [Parameter] public ICollection<LinkViewModel> Links { get; set; } = new List<LinkViewModel>();
    [Parameter] public string Vpn { get; set; } = string.Empty;
    [Parameter] public string Name { get; set; } = string.Empty;
    [Parameter] public double ScaleFactor { get; set; } = 1.02;
    [Inject] private IJSRuntime JS { get; set; } = null!;
    [Inject] private IDispatcher Dispatcher { get; set; } = null!;
    [Inject] private IState<AppState> AppState { get; set; } = null!;
    [Inject] private ToastService ToastService { get; set; } = null!;
    private MouseEventArgs PreviousMousePosition { get; set; } = null!;
    private ApplicationViewModel SelectedApplication { get; set; } = null!;
    private ApplicationViewModel ActiveApplication { get; set; } = null!;
    private LinkViewModel ActiveLink { get; set; } = null!;
    private LinkViewModel SelectedLink { get; set; } = null!;
    private LinkViewModel PendingLink { get; set; } = null!;
    private (ApplicationViewModel, AnchorViewModel) LinkedApplication { get; set; } = (null!, null!);
    private PointViewModel SelectedMouseOffset { get; set; } = null!;
    private PointViewModel SelectedCanvasOffset { get; set; } = null!;
    private PointViewModel DroppedElementPosition { get; set; } = null!;
    private IEnumerable<double> InitCanvasCoordinates { get; set; } = null!;
    private AsyncApiClient addClient { get; set; } = null!;
    private AsyncApiEventDef addEventDef { get; set; } = null!;

    public void UpdateLinks(ICollection<ApplicationViewModel> applications, ICollection<LinkViewModel> links)
    {
        foreach(var link in links)
        {
            var fromApp = applications.FirstOrDefault(a => a.ClientId == link.StartPoint.ApplicationId);
            var toApp = applications.FirstOrDefault(a => a.ClientId == link.EndPoint.ApplicationId);
            link.StartPoint.AnchorPosition = ComputeAnchorPosition(fromApp, toApp);
            link.EndPoint.AnchorPosition = ComputeAnchorPosition(toApp, fromApp);
            UpdateAnchorPosition(link.StartPoint, fromApp);
            UpdateAnchorPosition(link.EndPoint, toApp);
        }

        Applications = applications;
        Links = links;
        StateHasChanged();

        void UpdateAnchorPosition(LinkPointViewModel pointToUpdate, ApplicationViewModel app)
        {            
            var offset = app.ComputeAnchorOffset(pointToUpdate.AnchorPosition);
            pointToUpdate.X = offset.Item1;
            pointToUpdate.Y = offset.Item2;
        }

        AnchorPositions ComputeAnchorPosition(ApplicationViewModel from, ApplicationViewModel to)
        {
            var minX = from.CoordinateX - PADDING;
            var maxX = from.CoordinateX + WIDTH + PADDING;
            if (minX > to.CoordinateX) return AnchorPositions.LEFT;
            else if (maxX < to.CoordinateX) return AnchorPositions.RIGHT;
            else if (from.CoordinateY < to.CoordinateY) return AnchorPositions.BOTTOM;
            return AnchorPositions.TOP;
        }
    }

    protected async override Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        SubscribeToAction<AddApplicationDomainElementFailureAction>((act) =>
        {
            ToastService.AddError("ApplicationDomain", act.Message);
            StateHasChanged();
        });
        SubscribeToAction<AddApplicationDomainElementResultAction>((act) =>
        {            
            var newApplication = new ApplicationViewModel
            {
                ClientId = act.ElementId,
                CoordinateX = act.CoordinateX,
                CoordinateY = act.CoordinateY,
                IsActive = true,
                CreateDateTime = DateTime.UtcNow,
                // Purposes = client.Purposes
            };
            Applications.Add(newApplication);
            ActiveApplication = newApplication;
            ToastService.AddInfo("ApplicationDomain", "Application has been added into the application domain");
            StateHasChanged();
        });
        SubscribeToAction<RemoveApplicationDomainElementFailureAction>((act) =>
        {            
            ToastService.AddError("ApplicationDomain", act.Message);
            StateHasChanged();
        });
        SubscribeToAction<RemoveApplicationDomainElementResultAction>((act) =>
        {
            var application = Applications.Single(a => a.ClientId == act.ElementId);
            Applications.Remove(application);
            ToastService.AddInfo("ApplicationDomain", "Application has been removed from the application domain");
            StateHasChanged();
        });
        SubscribeToAction<RemoveApplicationDomainLinkResultAction>((act) =>
        {
            var link = Links.Single(l => l.StartPoint.ApplicationId == act.Source && l.EndPoint.ApplicationId == act.Target);
            Links.Remove(link);
            ToastService.AddInfo("ApplicationDomain", "Application link has been removed from the appliaction domain");
            StateHasChanged();
        });
        SubscribeToAction<AddApplicationDomainLinkResultAction>((act) =>
        {
            Links.Add(PendingLink);
            ToastService.AddInfo("ApplicationDomain", "Application link has been added into the appliaction domain");
            StateHasChanged();
        });
        SubscribeToAction<UpdateApplicationDomainCoordinatesResultAction>((act) =>
        {            
            ToastService.AddInfo("ApplicationDomain", "Coordinates have been updated");
            foreach(var app in Applications)
            {
                var coordinate = act.Coordinates.SingleOrDefault(c => c.ElementId == app.ClientId);
                if (coordinate == null) continue;
                app.CoordinateX = coordinate.CoordinateX;
                app.CoordinateY = coordinate.CoordinateY;
            }

            StateHasChanged();
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if(firstRender)
        {
            var size = await JS.InvokeAsync<ElementSize>("getSize", "asyncApiContainer");
            ViewBox = $"0 0 {size.Width} {size.Height}";
            InitCanvasCoordinates = GetViewBoxCoordinates();
        }
    }

    private async void HandleDrop(DragEventArgs args) 
    {
        var record = args.DataTransfer.Items.FirstOrDefault();
        if (record == null) return;
        switch(record.Type)
        {
            case "application":
                DroppedElementPosition = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", args.ClientX, args.ClientY);
                addClient.Open();
                break;
        }
    }

    private void HandleStartViewMode()
    {
        Mode = EditionModes.VIEW;
    }

    private void HandleStartEditMode()
    {
        Mode = EditionModes.EDIT;
    }

    private void HandleMouseDown(MouseEventArgs evt)
    {
        StartMoving = true;
        var splitted = GetViewBoxCoordinates();
        SelectedCanvasOffset = new PointViewModel
        {
            X = splitted.ElementAt(0),
            Y = splitted.ElementAt(1)
        };
        SelectedMouseOffset = new PointViewModel
        {
            X = evt.ClientX,
            Y = evt.ClientY
        };
        foreach (var app in Applications) app.IsActive = false;
        foreach (var link in Links) link.IsActive = false;
        ActiveApplication = null;
        ActiveLink = null;
    }

    private async void HandleSelectApplication(MouseEventArgs evt, ApplicationViewModel application)
    {
        var offset = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", evt.ClientX, evt.ClientY);
        offset.X -= application.CoordinateX;
        offset.Y -= application.CoordinateY;
        StartMoving = true;
        SelectedMouseOffset = offset;
        SelectedApplication = application.Clone();
        foreach (var app in Applications) app.IsActive = false;
        foreach (var link in Links) link.IsActive = false;
        application.IsActive = true;
        ActiveApplication = application;
        ActiveLink = null;
        IsApplicationMoving = false;
    }

    private void HandleSelectLink(MouseEventArgs evt, LinkViewModel link) 
    {
        foreach (var l in Links) l.IsActive = false;
        foreach (var app in Applications) app.IsActive = false;
        link.IsActive = true;
        ActiveLink = link;
        ActiveApplication = null;
    }

    private async void HandleStartDrawLink(MouseEventArgs evt, string applicationId, AnchorPositions position)
    {
        var pointViewModel = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", evt.ClientX, evt.ClientY);
        SelectedLink = new LinkViewModel
        {
            StartPoint = new LinkPointViewModel
            {
                X = pointViewModel.X,
                Y = pointViewModel.Y,
                AnchorPosition = position,
                ApplicationId = applicationId
            },
            EndPoint = new LinkPointViewModel
            {
                X = pointViewModel.X,
                Y = pointViewModel.Y,
                AnchorPosition = position,
                ApplicationId = applicationId
            }
        };
        StartMoving = true;
        var filtered = Applications.Where(a => a.ClientId != applicationId);
        foreach (var app in filtered) app.IsActive = true;
    }

    private async void HandleMouseMove(MouseEventArgs evt)
    {
        if (!StartMoving) return;
        switch(Mode)
        {
            case EditionModes.VIEW:
                MoveEditor();
                break;
            case EditionModes.EDIT:
                var offset = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", evt.ClientX, evt.ClientY);
                if(SelectedApplication != null) MoveApplication(offset);
                if(SelectedLink != null) MoveLink(offset);
                break;
        }

        async void MoveEditor()
        {
            var splitted = GetViewBoxCoordinates();
            if (SelectedCanvasOffset == null) return;
            var x = SelectedCanvasOffset.X - (evt.ClientX - SelectedMouseOffset.X);
            var y = SelectedCanvasOffset.Y - (evt.ClientY - SelectedMouseOffset.Y);
            UpdateViewBox(new double[] { x, y, splitted.ElementAt(2), splitted.ElementAt(3) });
        }

        void MoveApplication(PointViewModel offset)
        {
            IsApplicationMoving = true;
            SelectedApplication.CoordinateX = offset.X - SelectedMouseOffset.X;
            SelectedApplication.CoordinateY = offset.Y - SelectedMouseOffset.Y;
        }

        void MoveLink(PointViewModel offset) 
        {
            SelectedLink.EndPoint = new LinkPointViewModel
            {
                X = offset.X,
                Y = offset.Y
            };
        }
    }

    private void HandleMouseUp(MouseEventArgs evt)
    {
        StartMoving = false;
        if (SelectedApplication != null) MoveApplication();
        if (SelectedLink != null && LinkedApplication.Item1 != null) AddLink();
        SelectedApplication = null;
        SelectedLink = null;

        async void MoveApplication() 
        {
            if (!IsApplicationMoving) return;
            var targets = Links.Where(l => l.StartPoint.ApplicationId == SelectedApplication.ClientId).Select(l => l.EndPoint.ApplicationId).ToList();
            Debug.WriteLine("Move Application");
            var currentApplication = Applications.Single(a => a.ClientId == SelectedApplication.ClientId);
            currentApplication.CoordinateX = SelectedApplication.CoordinateX;
            currentApplication.CoordinateY = SelectedApplication.CoordinateY;
            var pointsToUpdate = Links.SelectMany(l => new List<LinkPointViewModel> { l.StartPoint, l.EndPoint }).Where(p => p.ApplicationId == currentApplication.ClientId);
            foreach (var pointToUpdate in pointsToUpdate)
            {
                var offset = currentApplication.ComputeAnchorOffset(pointToUpdate.AnchorPosition);
                pointToUpdate.X = offset.Item1;
                pointToUpdate.Y = offset.Item2;
            }
        }

        void AddLink()
        {
            if (SelectedLink.StartPoint.ApplicationId == LinkedApplication.Item1.ClientId) return;
            PendingLink = new LinkViewModel
            {
                StartPoint = SelectedLink.StartPoint,
                EndPoint = new LinkPointViewModel
                {
                    X = SelectedLink.EndPoint.X,
                    Y = SelectedLink.EndPoint.Y,
                    AnchorPosition = LinkedApplication.Item2.Position,
                    ApplicationId = LinkedApplication.Item1.ClientId
                }
            };
            addEventDef.Open();
        }
    }

    private async Task<bool> HandleMouseWheel(WheelEventArgs args)
    {
        long normalized;
        var delta = args.DeltaMode;
        if (delta != default(long)) normalized = (delta % 120) == 0 ? delta / 120 : delta / 12;
        else
        {
            if (args.DeltaY != default(double)) delta = (long)args.DeltaY;
            else if (args.Detail != default(long)) delta = args.Detail;
            else delta = 0;
            normalized = -(delta % 3 == 0 ? delta * 10 : delta / 3);
        }

        var scaleDelta = normalized > 0 ? 1 / ScaleFactor : ScaleFactor;
        var offset = await JS.InvokeAsync<PointViewModel>("computeCoordinate", "editor", args.ClientX, args.ClientY);
        var coordinates = GetViewBoxCoordinates();
        var x = coordinates.ElementAt(0) - ((coordinates.ElementAt(0) - offset.X) * (scaleDelta - 1));
        var y = coordinates.ElementAt(1) - ((coordinates.ElementAt(1) - offset.Y) * (scaleDelta - 1));
        var width = coordinates.ElementAt(2) * scaleDelta;
        var height = coordinates.ElementAt(3) * scaleDelta;
        UpdateViewBox(new double[] { x, y, width, height });
        return false;
    }

    private void HandleMouseOver(ApplicationViewModel application, AnchorViewModel anchor)
    {
        if (SelectedLink == null) return;
        LinkedApplication = (application, anchor);
    }

    private void HandleMouseOut(MouseEventArgs evt)
    {
        LinkedApplication = (null, null);
    }

    private void RemoveLink(LinkViewModel link)
    {
        Dispatcher.Dispatch(new RemoveApplicationDomainLinkAction { EventId = link.EventId, Name = Name, Port = AppState.Value.SelectedNode.Port, Url = AppState.Value.SelectedNode.Url, Source = link.StartPoint.ApplicationId, Target = link.EndPoint.ApplicationId, Vpn = Vpn });
    }

    private void CloseActiveApplication()
    {
        ActiveApplication.IsActive = false;
        ActiveApplication = null;
    }

    private void HandleSelectClient(ClientViewModel client)
    {
        addClient.Close();
        if (client == null || (client != null && Applications.Any(a => a.ClientId == client.Id))) return;        
        Dispatcher.Dispatch(new AddApplicationDomainElementAction { ElementId = client.Id, Name = Name, Vpn = Vpn, Url = AppState.Value.SelectedNode.Url, Port = AppState.Value.SelectedNode.Port, CoordinateX = DroppedElementPosition.X, CoordinateY = DroppedElementPosition.Y });
    }

    private void HandleSelectEvtDef(EventDefViewModel evtDef) 
    {
        addEventDef.Close();
        if (evtDef == null) return;
        Dispatcher.Dispatch(new AddApplicationDomainLinkAction { EventId = evtDef.Id, Name = Name, Vpn = Vpn, Url = AppState.Value.SelectedNode.Url, Port = AppState.Value.SelectedNode.Port, Source = PendingLink.StartPoint.ApplicationId, Target = PendingLink.EndPoint.ApplicationId });
    }

    private void RemoveApplication(ApplicationViewModel application)
    {
        Dispatcher.Dispatch(new RemoveApplicationDomainElementAction { ElementId = application.ClientId, Name = Name, Vpn = Vpn, Url = AppState.Value.SelectedNode.Url, Port = AppState.Value.SelectedNode.Port });
    }

    private void HandleCloseApplication()
    {
        ActiveApplication.IsActive = false;
        ActiveApplication = null;
    }

    private void HandleCloseLink()
    {
        ActiveLink.IsActive = false;
        ActiveLink = null;
    }

    private void Close() 
    {
        addClient.Close();
    }

    private async void Update()
    {
        Dispatcher.Dispatch(new UpdateApplicationDomainCoordinatesAction 
        { 
            Name = Name, 
            Vpn = Vpn, 
            Url = AppState.Value.SelectedNode.Url,
            Port = AppState.Value.SelectedNode.Port,
            Coordinates = Applications.Select(a => new ApplicationDomainCoordinate
            {
                ElementId = a.ClientId,
                CoordinateX = a.CoordinateX,
                CoordinateY = a.CoordinateY
            }).ToList()
        });
    }

    private class ElementSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private enum EditionModes
    {
        EDIT = 0,
        VIEW = 1
    }

    private IEnumerable<double> GetViewBoxCoordinates()
    {
        return CoordinateHelper.Parse(ViewBox);
    }

    private void UpdateViewBox(IEnumerable<double> coordinates)
    {
        ViewBox = CoordinateHelper.Sanitize(coordinates);
    }
}