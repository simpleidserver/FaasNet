@using System.Diagnostics
@using FaasNet.EventMesh.UI.Helpers
@using FaasNet.EventMesh.UI.Stores.Client

<div id="asyncApiContainer">
    <div id="toolbox">
        <ul>
            @if (Mode == EditionModes.EDIT)
            {
                <li>
                    <i @onclick="() => HandleStartViewMode()" class="fa-solid fa-arrows-up-down-left-right"></i>
                </li>
            }
            else
            {                
                <li>
                    <i @onclick="() => HandleStartEditMode()" class="fa-solid fa-pen-to-square"></i>
                </li>
            }
        </ul>
    </div>
    <div id="elements">
        <div class="element" draggable="true" ondragstart="event.dataTransfer.setData('application', '')">
            Application
        </div>
    </div>
    <svg id="editor" class="@(Mode == EditionModes.VIEW ? "moving" : "")" viewBox="@ViewBox" 
                @onmousewheel="HandleMouseWheel" 
                @onmousewheel:stopPropagation="true"
                @ondrop="HandleDrop" 
                ondragover="event.preventDefault();" 
                @onmousedown="HandleMouseDown" 
                @onmousemove="HandleMouseMove" 
                @onmouseup="HandleMouseUp">
        <defs>
            <marker id="asyncapieditor-barbEnd" refX="19" refY="7" markerWidth="20" markerHeight="14" markerUnits="strokeWidth" orient="auto">
                <path d="M 19,7 L9,13 L14,7 L9,1 Z"></path>
            </marker>
        </defs>
        <g class="children">
            @foreach (var application in Applications)
            {
                <g class="@(SelectedApplication != null && application.Id == SelectedApplication.Id ? "application selected" : "application")" 
                        transform="@application.Matrix" 
                        @onmousedown="(e) => HandleSelectApplication(e, application)" 
                        @onmousedown:stopPropagation="true">
                    <foreignObject width="@application.Width" height="@application.Height" class="appContainer">
                        @foreach(var anchor in application.Anchors)
                        {                            
                            <div class="@anchor.ClassName" @onmouseover="() => HandleMouseOver(application, anchor)" @onmouseout="HandleMouseOut" @onmousedown="(e) => HandleStartDrawLink(e, application.Id, anchor.Position)" @onmousedown:preventDefault="true" @onmousedown:stopPropagation="true"></div>
                        }
                        <div class="content">
                            <div class="header">
                                @application.ClientId
                                <div class="actions">
                                    <i class="fa-solid fa-trash" @onclick="() => RemoveApplication(application)"></i>
                                </div>
                            </div>
                        </div>
                    </foreignObject>
                </g>
            }

            @foreach(var link in Links)
            {
                <path d="@link.Path" marker-end="url(#asyncapieditor-barbEnd)" stroke="black" fill="none"></path>
            }
        </g>
        @if(SelectedApplication != null)
        {
            <g class="application" transform="@SelectedApplication.Matrix" draggable="true">
                <foreignObject width="@SelectedApplication.Width" height="@SelectedApplication.Height" class="appContainer">
                    <div class="content">
                        <div class="header">
                            @SelectedApplication.ClientId
                        </div>
                    </div>
                </foreignObject>
            </g>
        }

        @if(SelectedLink != null)
        {
            <path d="@SelectedLink.Path" marker-end="url(#asyncapieditor-barbEnd)" stroke="black" fill="none"></path>
        }
    </svg>
</div>

<Modal Title="Add Client" @ref=addClientModal>
    <EditForm OnValidSubmit="@HandleValidSubmit" Model="addClient">
        <DataAnnotationsValidator />
        <div class="modal-body">
            <!-- ClientId -->
            <div class="mb-3">
                <label class="form-label">Client Identifier</label>
                <InputText class="form-control" @bind-Value="addClient.ClientId" />
                <ValidationMessage For="() => addClient.ClientId" />
            </div>
            <!-- VPN -->
            <div class="mb-3">
                <label class="form-label">VPN</label>
                <input type="text" value="@addClient.Vpn" class="form-control" disabled />
                <ValidationMessage For="() => addClient.Vpn" />
            </div>
            <!-- Purpose Types -->
            <div class="mb-3">
                <label class="form-label">Types of purpose</label>
                <select class="form-select" @bind="addClient.PurposeTypes" multiple>
                    <option value="0">Publish</option>
                    <option value="1">Subscribe</option>
                </select>
                <ValidationMessage For="() => addClient.PurposeTypes" />
            </div>
        </div>
        <div class="modal-footer">
            <button type="button" class="btn btn-secondary" @onclick="Close">Close</button>
            <button type="submit" class="btn btn-primary">Add</button>
        </div>
    </EditForm>
</Modal>

@code {
    private ICollection<ApplicationViewModel> Applications { get; set; } = new List<ApplicationViewModel>();
    private ICollection<LinkViewModel> Links { get; set; } = new List<LinkViewModel>();
    private string ViewBox { get; set; } = null!;
    private EditionModes Mode { get; set; } = EditionModes.EDIT;
    private bool StartMoving { get; set; } = false;
    [Inject]
    private IJSRuntime JS { get; set; }
    [Parameter]
    public string Vpn { get; set; }
    [Parameter]
    public double ScaleFactor { get; set;} = 1.02;
    private MouseEventArgs PreviousMousePosition { get; set; } = null!;
    private ApplicationViewModel SelectedApplication { get; set; } = null!;
    private (ApplicationViewModel, AnchorViewModel) LinkedApplication { get; set; } = (null, null);
    private PointViewModel SelectedMouseOffset { get; set; } = null!;
    private PointViewModel SelectedCanvasOffset { get; set; } = null!;
    private LinkViewModel SelectedLink { get; set; } = null!;
    private IEnumerable<double> InitCanvasCoordinates { get; set; } = null!;
    private Modal addClientModal { get; set; }
    private AddClientAction addClient { get; set; } = new AddClientAction();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if(firstRender)
        {
            var size = await JS.InvokeAsync<ElementSize>("getSize", "asyncApiContainer");
            ViewBox = $"0 0 {size.Width} {size.Height}";
            InitCanvasCoordinates = GetViewBoxCoordinates();
            addClient.Vpn = Vpn;
        }
    }

    private async void HandleDrop(DragEventArgs args) 
    {
        var record = args.DataTransfer.Items.FirstOrDefault();
        if (record == null) return;
        switch(record.Type)
        {
            case "application":
                var offset = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", args.ClientX, args.ClientY);
                Applications.Add(new ApplicationViewModel
                {
                    Id = Guid.NewGuid().ToString(),
                    ClientId = "New application",
                    CoordinateX = offset.X,
                    CoordinateY = offset.Y
                });
                break;
        }
    }

    private void HandleStartViewMode()
    {
        Mode = EditionModes.VIEW;
    }

    private void HandleStartEditMode()
    {
        Mode = EditionModes.EDIT;
    }

    private void HandleMouseDown(MouseEventArgs evt)
    {
        StartMoving = true;
        var splitted = GetViewBoxCoordinates();
        SelectedCanvasOffset = new PointViewModel
        {
            X = splitted.ElementAt(0),
            Y = splitted.ElementAt(1)
        };
        SelectedMouseOffset = new PointViewModel
        {
            X = evt.ClientX,
            Y = evt.ClientY
        };
    }

    private async void HandleSelectApplication(MouseEventArgs evt, ApplicationViewModel application)
    {
        var offset = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", evt.ClientX, evt.ClientY);
        offset.X -= application.CoordinateX;
        offset.Y -= application.CoordinateY;
        StartMoving = true;
        SelectedMouseOffset = offset;
        SelectedApplication = application.Clone();
    }

    private async void HandleStartDrawLink(MouseEventArgs evt, string applicationId, AnchorPositions position)
    {
        var pointViewModel = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", evt.ClientX, evt.ClientY);
        SelectedLink = new LinkViewModel
        {
            StartPoint = new LinkPointViewModel
            {
                X = pointViewModel.X,
                Y = pointViewModel.Y,
                AnchorPosition = position,
                ApplicationId = applicationId
            },
            EndPoint = new LinkPointViewModel
            {
                X = pointViewModel.X,
                Y = pointViewModel.Y,
                AnchorPosition = position,
                ApplicationId = applicationId
            }
        };
        StartMoving = true;
    }

    private async void HandleMouseMove(MouseEventArgs evt)
    {
        if (!StartMoving) return;
        switch(Mode)
        {
            case EditionModes.VIEW:
                MoveEditor();
                break;
            case EditionModes.EDIT:
                var offset = await JS.InvokeAsync<PointViewModel>("getApplicationMousePosition", "editor", evt.ClientX, evt.ClientY);
                if(SelectedApplication != null) MoveApplication(offset);
                if(SelectedLink != null) MoveLink(offset);
                break;
        }

        async void MoveEditor()
        {
            var splitted = GetViewBoxCoordinates();
            if (SelectedCanvasOffset == null) return;
            var x = SelectedCanvasOffset.X - (evt.ClientX - SelectedMouseOffset.X);
            var y = SelectedCanvasOffset.Y - (evt.ClientY - SelectedMouseOffset.Y);
            UpdateViewBox(new double[] { x, y, splitted.ElementAt(2), splitted.ElementAt(3) });
        }

        void MoveApplication(PointViewModel offset)
        {
            SelectedApplication.CoordinateX = offset.X - SelectedMouseOffset.X;
            SelectedApplication.CoordinateY = offset.Y - SelectedMouseOffset.Y;
        }

        void MoveLink(PointViewModel offset) 
        {
            SelectedLink.EndPoint = new LinkPointViewModel
            {
                X = offset.X,
                Y = offset.Y
            };
        }
    }

    private void HandleMouseUp(MouseEventArgs evt)
    {
        StartMoving = false;
        if (SelectedApplication != null) MoveApplication();
        if (SelectedLink != null && LinkedApplication.Item1 != null) AddLink();
        SelectedApplication = null;
        SelectedLink = null;

        void MoveApplication() {            
            var currentApplication = Applications.Single(a => a.Id == SelectedApplication.Id);
            currentApplication.CoordinateX = SelectedApplication.CoordinateX;
            currentApplication.CoordinateY = SelectedApplication.CoordinateY;
            var pointsToUpdate = Links.SelectMany(l => new List<LinkPointViewModel> { l.StartPoint, l.EndPoint }).Where(p => p.ApplicationId == currentApplication.Id);
            foreach(var pointToUpdate in pointsToUpdate)
            {
                var offset = currentApplication.ComputeAnchorOffset(pointToUpdate.AnchorPosition);
                pointToUpdate.X = offset.Item1;
                pointToUpdate.Y = offset.Item2;
            }
        }

        void AddLink()
        {
            if (SelectedLink.StartPoint.ApplicationId == LinkedApplication.Item1.Id) return;
            Links.Add(new LinkViewModel
            {
                StartPoint = SelectedLink.StartPoint,
                EndPoint = new LinkPointViewModel
                {
                    X = SelectedLink.EndPoint.X,
                    Y = SelectedLink.EndPoint.Y,
                    AnchorPosition = LinkedApplication.Item2.Position,
                    ApplicationId = LinkedApplication.Item1.Id
                }
            });
        }
    }

    private void RemoveApplication(ApplicationViewModel application)
    {
        Applications.Remove(application);
        Links = Links.Where(l => !l.IsLinkedToApplication(application.Id)).ToList();
    }

    private async Task<bool> HandleMouseWheel(WheelEventArgs args) 
    {
        long normalized;
        var delta = args.DeltaMode;
        if (delta != default(long)) normalized = (delta % 120) == 0 ? delta / 120 : delta / 12;
        else
        {
            if (args.DeltaY != default(double)) delta = (long)args.DeltaY;
            else if (args.Detail != default(long)) delta = args.Detail;
            else delta = 0;
            normalized = -(delta % 3 == 0 ? delta * 10 : delta / 3);
        }

        var scaleDelta = normalized > 0 ? 1 / ScaleFactor : ScaleFactor;
        var offset = await JS.InvokeAsync<PointViewModel>("computeCoordinate", "editor", args.ClientX, args.ClientY);
        var coordinates = GetViewBoxCoordinates();
        var x = coordinates.ElementAt(0) - ((coordinates.ElementAt(0) - offset.X) * (scaleDelta - 1));
        var y = coordinates.ElementAt(1) - ((coordinates.ElementAt(1) - offset.Y) * (scaleDelta - 1));
        var width = coordinates.ElementAt(2) * scaleDelta;
        var height = coordinates.ElementAt(3) * scaleDelta;
        UpdateViewBox(new double[] { x, y, width, height });
        return false;
    }

    private void HandleMouseOver(ApplicationViewModel application, AnchorViewModel anchor) 
    {
        if (SelectedLink == null) return;
        LinkedApplication = (application, anchor);
    }

    private void HandleMouseOut(MouseEventArgs evt)
    {
        LinkedApplication = (null, null);
    }

    private void HandleValidSubmit()
    {

    }

    private void Close() 
    {
        addClientModal.Close();
    }

    private class ElementSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private enum EditionModes
    {
        EDIT = 0,
        VIEW = 1
    }

    private IEnumerable<double> GetViewBoxCoordinates()
    {
        return CoordinateHelper.Parse(ViewBox);
    }

    private void UpdateViewBox(IEnumerable<double> coordinates)
    {
        ViewBox = CoordinateHelper.Sanitize(coordinates);
    }
}